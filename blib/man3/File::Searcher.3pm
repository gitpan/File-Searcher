.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Searcher 3"
.TH Searcher 3 "2001-09-25" "perl v5.8.5" "User Contributed Perl Documentation"
.SH "NAME"
File::Searcher \-\- Searches for files and performs search/replacements
on matching files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 25
\&        use File::Searcher;
\&        my $search = File::Searcher->new('*.cgi');
\&        $search->add_expression(name=>'street',
\&            search=>'1234 Easy St.',
\&            replace=>'456 Hard Way',
\&            options=>'i');
\&        $search->add_expression(name=>'department',
\&            search=>'(Dept\e.|Department)(\es+)(\ed+)',
\&            replace=>'$1$2$3',
\&            options=>'im');
\&        $search->add_expression(name=>'place',
\&            search=>'Portland, OR(.*?)97212',
\&            replace=>'Vicksburg, MI${1}49097',
\&            options=>'is');
\&        $search->start;
\&        # $search->interactive; SEE File::Searcher::Interactive
\&        @files_matched = $search->files_matched;
\&        print "Files Matched\en";
\&        print "\et" . join("\en\et", @files_matched) . "\en";
\&        print "Total Files:\et" . $search->file_cnt . "\en";
\&        print "Directories:\et" . $search->dir_cnt . "\en";
\&        my @files_replaced = $search->expression('street')->files_replaced;
\&        my @files_replaced = $search->expression($expression)->files_replaced;
\&        my %matches = $search->expression('street')->matches;
\&        my %replacements = $search->expression('street')->replacements;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`File::Searcher\*(C'\fR allows for the traversing of a directory tree for
files matching a Perl regular expression. When a match is found, the
statistics are stored and if the file is a text file a series of
searches and replacements can be performed. \f(CW\*(C`File::Searcher\*(C'\fR has
options that allow for backing-up / archiving files and has \s-1OO\s0 access
to reporting and statistics of matches and replacements.
.SH "USAGE"
.IX Header "USAGE"
.Sh "General Use"
.IX Subsection "General Use"
.Vb 1
\&  # constructor - with options
.Ve
.PP
.Vb 12
\&  my $search = File::Searcher->new(
\&    file_expression=>'*.txt', # required unless files
\&    files=>\e@files,                 # required unless file_expression
\&    start_directory=> '/path/to/dir',       # default './'
\&    backup_extension=> '~',             # default '.bak'
\&    do_backup=> '0',                # default 1 will create backup file
\&    recurse_subs=> '0',             # default 1 will recurse subs
\&    do_replace=> '1',               # default 0 will not replace matches
\&    log_mode=> '111',               # unimplemented
\&    archive=>'my_archive.tgz',          # default is /start_directory/(system time).tgz
\&    do_archive=> '1', # default 0 will not archive matched files
\& );
.Ve
.PP
.Vb 1
\&  # constructor - with file expression
.Ve
.PP
.Vb 1
\&  my $search = File::Searcher->new('*.txt');
.Ve
.PP
.Vb 1
\&  # constructor - with ref to array of absolute paths
.Ve
.PP
.Vb 1
\&  my $search = File::Searcher->new(\e@files);
.Ve
.PP
The constructor comes in 3 flavors; with options, with file expression,
or reference to array of absolute paths. If you do not specify the
options in the constructor, they can be set by accessor methods.
.PP
.Vb 7
\&   $search->start_directory('/path/to/dir');
\&   $search->backup_extension('~');
\&   $search->do_backup(0);
\&   $search->recurse_subs(0);
\&   $search->do_replace(1);
\&   $search->archive('my_archive.tgz');
\&   $search->do_archive(0);
.Ve
.PP
Next, the series of expressions are set with options. Expressions will
be searched in the order which they are added to the search.
.PP
.Vb 6
\&   $search->add_expression(
\&      name=>'street', # required
\&      search=>'1234 Easy St.',
\&      replace=>'456 Hard Way',
\&      case_insensitive=>1,
\&   );
.Ve
.PP
.Vb 7
\&    $search->add_expression(
\&      name=>'department',
\&      search=>'(Dept\e.|Department)(\es+)(\ed+)',
\&      replace=>'$1$2$3',
\&      case_insensitive=>1,
\&      multiline=>1,
\&    );
.Ve
.PP
.Vb 5
\&   $search->add_expression(
\&      name=>'place',
\&      search=>'Portland, OR(.*?)97212',
\&      replace=>'Vicksburg, MI${1}49097',
\&      singleline=>1,);
.Ve
.PP
Expression options can be set in two ways:
.PP
.Vb 2
\&   # as a single string
\&   ...add_expression(..., options=> 'ismx');
.Ve
.PP
.Vb 2
\&   # as named paramaters
\&   ...add_expression(..., singleline=>1, multiline=>1,case_insensitive=>1, extended=>1);
.Ve
.PP
.Vb 1
\&   # Run search
.Ve
.PP
.Vb 1
\&   $search->start;
.Ve
.Sh "Expanded Functionality"
.IX Subsection "Expanded Functionality"
For expanded FUN-ctionality set references to subroutines to process
when a file match is encountered \f(CW\*(C`on_file_match\*(C'\fR and when a search
expression is encountered \f(CW\*(C`on_expression_match\*(C'\fR.
.PP
.Vb 9
\&   $search->on_file_match(sub{
\&   my ($file) = @_;
\&    return 0 unless $file->writable_r; # writable by real id?
\&    return 0 unless $file->stats->size_bytes < 100;
\&    chmod(0777, $file->path);
\&    return 1;
\&   });
\&   # alternatively
\&   # $search->on_file_match(\e&my_sub);
.Ve
.PP
\&\f(CW\*(C`on_file_match\*(C'\fR receives a file object with properties methods
(path, readable_e, writable_e, executable_e, readable_r, writable_r,
executable_r, owned_e, owned_r, exist, exist_non_zero, zero_size, file,
directory, link_, pipe_, socket_, block, character, setuid_bit,
setgid_bit, sticky_bit, opened_tty, text, binary)
if it is a file it also has stats methods (device_code, inode_number,
mode_flags, link_cnt, user_id, group_id, device_type, size_bytes,
time_access_seconds, time_modified_seconds, time_status_seconds,
block_system, block_file, time_access_string, time_modified_string,
time_status_string, mode_string)
returns 1 to continue processing files (i.e. look for matches to expressions)
returns 0 to move to next file
.PP
.Vb 11
\&   $search->on_expression_match( sub{
\&    my ($match,$expression) = @_;
\&    return -100 if scalar($expression->files_replaced) > 7;
\&    return -10 if length($match->post) < 120;
\&    return 1 if $match->match =~ /special(.*?)case/;
\&    return 10 unless $match->contents =~ /special/;
\&    # this is sort of what this module does, but,hey!
\&    my $file_contents = $match->contents;
\&    eval("\e$contents =~ s/$match->search/$match->replace/g$match->options;");
\&    return $contents;
\&   });
.Ve
.PP
.Vb 2
\&   # alternatively
\&   # $search->on_expression_match(\e&my_sub);
.Ve
.PP
\&\f(CW\*(C`on_expression_match\*(C'\fR receives a \f(CW\*(C`match\*(C'\fR object with methods(match, pre, post, last, start_offset, end_offset,contents),
\&\f(CW\*(C`expression\*(C'\fR object access expression options (search, replace, options, \f(CW%replacements\fR, \f(CW%matches\fR, \f(CW@files_replaced\fR)
.PP
.Vb 7
\&   returns -100 to ignore expression, and do not search for it again in any file
\&   returns -10 to skip to next file
\&   returns -1 to skip to next match (possibly next file)
\&   returns 1 to process match (as specified in $search object)
\&   returns 10 to process all matches in file
\&   returns 100 to process all occurences in all files
\&   returns $content (scalar) of file contents, overwrites contents (only to file if specified) and moves to next file
.Ve
.Sh "Reporting"
.IX Subsection "Reporting"
To see what happened, for the search and each expression, access results.
.PP
.Vb 1
\&   # search results reports
.Ve
.PP
.Vb 13
\&   @files_matched = $search->files_matched;
\&   print "Files Matched\en";
\&   print "\et" . join("\en\et", @files_matched) . "\en";
\&   print "Text Files:\et" . $search->file_text_cnt . "\en";
\&   print "Binary Files:\et" . $search->file_binary_cnt . "\en";
\&   print "Uknown Files:\et" . $search->file_unknown_cnt . "\en";
\&   print "Total Files:\et" . $search->file_cnt . "\en";
\&   print "Directories:\et" . $search->dir_cnt . "\en";
\&   print "Hard Links:\et" . $search->link_cnt . "\en";
\&   print "Sockets:\et" . $search->socket_cnt . "\en";
\&   print "Pipes:\et" . $search->pipe_cnt . "\en";
\&   print "Uknown Entries:\et" . $search->unknown_cnt . "\en";
\&   print "\en";
.Ve
.PP
.Vb 1
\&   # expression results reports
.Ve
.PP
.Vb 1
\&   foreach my $expression (@{$search->get_expressions}){
.Ve
.PP
.Vb 3
\&      my @files_replaced = $search->expression($expression)->files_replaced;
\&      my %matches = $search->expression($expression)->matches;
\&      my %replacements = $search->expression($expression)->replacements;
.Ve
.PP
.Vb 3
\&      print "Search/Replace:\et" .>
\&      $search->expression($expression)->search .
\&      "\et" . $search->expression($expression)->replace . "\en";
.Ve
.PP
.Vb 2
\&      print "\etNo Replacements Made\en" and next if @files_replaced < 1;
\&      print "\etFile\et\et\et\et\etMatches\etReplacements\en";
.Ve
.PP
.Vb 5
\&      foreach my $file (@files_replaced){
\&         print "\et$file\et\et$matches{$file}\et$replacements{$file}\en";
\&      }
\&        print "\en";
\&   }
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
Super complex regular expressions probably won't work the way you think
they will.
.SH "BUGS"
.IX Header "BUGS"
Let me know...
.SH "TO DO"
.IX Header "TO DO"
.IP "* More advanced functionality" 4
.IX Item "More advanced functionality"
.PD 0
.IP "* More reporting (line numbers, etc.)" 4
.IX Item "More reporting (line numbers, etc.)"
.IP "* Maybe get rid of Class::Generate" 4
.IX Item "Maybe get rid of Class::Generate"
.PD
.SH "SEE ALSO"
.IX Header "SEE ALSO"
File::Searcher::Interactive, File::Find,
File::Copy, File::Flock, Class::Struct::FIELDS, Class::Generate, Cwd,
Time::localtime, Archive::Tar
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2000, Adam Stubbs
This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself. Please email me if you find this
module useful.
.SH "AUTHOR"
.IX Header "AUTHOR"
Adam Stubbs, \f(CW\*(C`astubbs@advantagecommunication.com\*(C'\fR
Version 0.91, Last Updated Tue Sep 25 23:08:50 \s-1EDT\s0 2001
